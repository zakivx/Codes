<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Template Filler</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
#templateEditor { width: 98%; min-height: 120px; border: 1px solid #ccc; padding: 10px; font-size: 16px; white-space: pre-wrap; outline: none; }
#fieldsContainer { padding-top: 20px; }
.fieldItem, .titleItem { border: 1px solid #ddd; border-radius: 5px; padding: 8px; margin-bottom: 8px; background: #f9f9f9; cursor: grab; }
.fieldItem.dragging, .titleItem.dragging { opacity: 0.5; }
.fieldLabel { font-weight: bold; margin-right: 10px; }
.titleItem { font-weight: bold; text-align: left; background: #ffc5c5; }
.inputField { display: block; width: 100%; max-width: 600px; margin-top: 5px; font-size: 16px; padding: 6px; box-sizing: border-box; resize: none; overflow: hidden; }
#result { margin-top: 20px; white-space: pre-wrap; border: 1px solid #ddd; padding: 10px; }
button { margin-top: 10px; margin-right: 10px; padding: 8px 12px; font-size: 14px; }
</style>
</head>
<body>

<h2>Template Editor</h2>
<div id="templateEditor" contenteditable="true" oninput="onEditorInput()"></div>
<textarea id="templateInput" style="display:none;"></textarea>

<button onclick="insertField()">Insert Field</button>
<button onclick="insertCheckbox()">Add Checkbox</button>
<button onclick="insertTitle()">Add Title</button>
<div id="fieldsContainer"></div>

<h3>Result</h3>
<div id="result"></div>
<button onclick="copyResult()">Copy Result</button>
<button onclick="saveAsHTML()">Save as file.html</button>

<script>
function onEditorInput() {
    const editor = document.getElementById('templateEditor');
    const text = editor.innerText;
    document.getElementById('templateInput').value = text;
    highlightTemplate();
    generateFields();
}

function highlightTemplate() {
    const editor = document.getElementById('templateEditor');
    const caretOffset = getCaretCharacterOffsetWithin(editor);
    const rawText = editor.innerText;
    const highlighted = rawText.replace(/\{\{\s*([\w\s-]+?)\s*\|\s*([^}]+?)\s*\}\}/g,
        (_, field, value) => {
            if (field.trim() === "title") return `{{<span style="color:blue">${field}</span> | <span style="color:purple">${value}</span>}}`;
            return `{{<span style="color:red">${field}</span> | <span style="color:green">${value}</span>}}`;
        }).replace(/\n/g, "<br>").replace(/ {2}/g, " &nbsp;");
    editor.innerHTML = highlighted;
    restoreCaretToOffset(editor, caretOffset);
}

function getCaretCharacterOffsetWithin(element) {
    let caretOffset = 0;
    const sel = window.getSelection();
    if (sel.rangeCount > 0) {
        const range = sel.getRangeAt(0);
        const preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(element);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        caretOffset = preCaretRange.toString().length;
    }
    return caretOffset;
}

function restoreCaretToOffset(container, offset) {
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
    let currentOffset = 0;
    while (walker.nextNode()) {
        const node = walker.currentNode;
        if (currentOffset + node.length >= offset) {
            const range = document.createRange();
            range.setStart(node, offset - currentOffset);
            range.collapse(true);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            return;
        }
        currentOffset += node.length;
    }
}

function generateFields() {
    const text = document.getElementById('templateInput').value;
    const matches = [...text.matchAll(/\{\{\s*([\w\s-]+?)\s*\|\s*([^}]+?)\s*\}\}/g)];
    const fieldsContainer = document.getElementById('fieldsContainer');
    fieldsContainer.innerHTML = '';

    matches.forEach(([_, field, defaultValue]) => {
        field = field.trim();
        let wrapper;
        if (field === "title") {
            wrapper = document.createElement('div');
            wrapper.className = 'titleItem';
            wrapper.draggable = true;
            wrapper.textContent = defaultValue;
        } else {
            wrapper = document.createElement('div');
            wrapper.className = 'fieldItem';
            wrapper.draggable = true;
            const label = document.createElement('span');
            label.className = 'fieldLabel';
            label.textContent = field;
            wrapper.appendChild(label);
            if (defaultValue.startsWith("checkbox:")) {
                const checked = defaultValue.split(":")[1] === "true";
                const checkbox = document.createElement('input');
                checkbox.type = "checkbox";
                checkbox.name = field;
                checkbox.checked = checked;
                checkbox.onchange = updateResult;
                wrapper.appendChild(checkbox);
            } else {
                const textarea = document.createElement('textarea');
                textarea.className = 'inputField';
                textarea.name = field;
                textarea.value = defaultValue;
                textarea.oninput = updateResult;
                textarea.addEventListener('input', ()=>autoResize(textarea));
                wrapper.appendChild(textarea);
                requestAnimationFrame(()=>requestAnimationFrame(()=>autoResize(textarea)));
            }
        }
        fieldsContainer.appendChild(wrapper);
    });
    enableDragSort(fieldsContainer);
    updateResult();
}

function enableDragSort(container) {
    container.querySelectorAll('.fieldItem, .titleItem').forEach(item => {
        item.addEventListener('dragstart', e => { item.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; });
        item.addEventListener('dragend', ()=>{ item.classList.remove('dragging'); updateResult(); });
        item.addEventListener('dragover', e => {
            e.preventDefault();
            const dragging = container.querySelector('.dragging');
            const afterElement = getDragAfterElement(container, e.clientY);
            if (afterElement==null) container.appendChild(dragging); else container.insertBefore(dragging, afterElement);
        });
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.fieldItem:not(.dragging), .titleItem:not(.dragging)')];
    return draggableElements.reduce((closest, child)=>{
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height/2;
        if(offset<0 && offset>closest.offset) return {offset: offset, element: child};
        else return closest;
    }, {offset:Number.NEGATIVE_INFINITY}).element;
}

function autoResize(el){ el.style.height='40px'; el.style.height=el.scrollHeight+'px'; }

function updateResult() {
    let result = document.getElementById('templateInput').value;
    const inputs = document.querySelectorAll('#fieldsContainer textarea, #fieldsContainer input[type="checkbox"], #fieldsContainer .titleItem');
    inputs.forEach(input => {
        if(input.classList.contains("titleItem")) {
            const value = input.textContent;
            const regex = new RegExp(`\\{\\{\\s*title\\s*\\|\\s*[^}]+?\\s*\\}\\}`,'g');
            result = result.replace(regex, value);
        } else {
            const field = input.name;
            const escapedField = field.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
            let value;
            if(input.type==="checkbox") value = `${field} : ${input.checked?"yes":"no"}`;
            else value = input.value;
            const regex = new RegExp(`\\{\\{\\s*${escapedField}\\s*\\|\\s*[^}]+?\\s*\\}\\}`,'g');
            result = result.replace(regex,value);
        }
    });
    document.getElementById('result').textContent=result;
}

function copyResult() {
    navigator.clipboard.writeText(document.getElementById('result').innerText).then(()=>alert("Result copied to clipboard."));
}

function insertField() {
    const fieldName = prompt("Field name:"); if(!fieldName) return;
    const defaultValue = prompt("Default value:");
    insertAtCaret(`{{${fieldName} | ${defaultValue}}}`);
}

function insertCheckbox() {
    const fieldName = prompt("Checkbox field name:"); if(!fieldName) return;
    insertAtCaret(`{{${fieldName} | checkbox:false}}`);
}

function insertTitle() {
    const titleName = prompt("Title text:"); if(!titleName) return;
    insertAtCaret(`{{title | ${titleName}}}`);
}

function insertAtCaret(text){
    const editor=document.getElementById('templateEditor');
    const selection=window.getSelection();
    if(!selection.rangeCount) return;
    const range=selection.getRangeAt(0);
    range.deleteContents();
    const textNode=document.createTextNode(text);
    range.insertNode(textNode);
    range.setStartAfter(textNode);
    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
    onEditorInput();
}

function saveAsHTML(){
    const docClone = document.documentElement.cloneNode(true);
    const editorClone = docClone.querySelector('#templateEditor');
    const plainText = document.getElementById('templateInput').value;
    editorClone.textContent = plainText; // save current edits
    const fullHTML = "<!DOCTYPE html>\n"+docClone.outerHTML;
    const blob=new Blob([fullHTML],{type:"text/html"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url; a.download="template.html"; a.click();
    URL.revokeObjectURL(url);
}

// Load template or saved content and render fields immediately
window.onload = ()=>{
    const editor = document.getElementById('templateEditor');
    if(editor.innerText.trim() === "") {
        const defaultTemplate = `Patient Information:
{{title | General}}
A {{age | 45}}-year-old {{sex | female}} with a history of {{history | hypertension}} 
presents with {{chief_complaint | chest pain}}.

Examination:
Vital signs show {{vital_signs | BP 150/90 mmHg, HR 95 bpm}}.  
Physical examination reveals {{physical_exam | normal heart sounds with no murmurs}}.

{{title | Investigations}}
Laboratory findings: {{lab_findings | elevated troponin, normal CBC}}.  
Imaging: {{imaging | ECG with ST elevation in leads II, III, aVF}}.

{{title | Risk Factors}}
{{Smoker | checkbox:true}}  
{{Diabetes | checkbox:false}}  
{{Alcohol use | checkbox:false}}  

{{title | Management}}
Initial management included {{management | aspirin, oxygen, nitrates}}.  
Further plan: {{plan | referral to cardiology for PCI}}.`;
        document.getElementById('templateInput').value = defaultTemplate;
        editor.innerText = defaultTemplate;
    }

    // **Trigger onEditorInput to render fields immediately**
    onEditorInput();
};
</script>
</body>
</html>
