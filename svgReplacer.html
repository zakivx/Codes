<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SVG Image Replacer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    .item {
      margin-bottom: 40px;
    }
    /* You can switch to width:100% if you want full-bleed scaling */
    svg, img {
      max-width: 100%;
      height: auto;
      display: block;
      margin-top: 10px;
      border: 1px solid #ccc;
    }
    .notice {
      color: red;
      font-size: 14px;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <h1>SVG Image Replacer</h1>
  <div id="output"></div>

  <script>
    // Example library mapping
    const library = {
      "https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Testosterone_estradiol_conversion.png/500px-Testosterone_estradiol_conversion.png": ["svg1500", "xx1"],
      "https://othersite.com/image2.jpg": ["svg1501", "xx1"],
      "https://www.pnas.org/cms/10.1073/pnas.1202588109/asset/c5f4bd03-2d62-47ed-9f11-bf233a019a6d/assets/graphic/pnas.1202588109fig06.jpeg,https://www.researchgate.net/publication/351724955/figure/fig3/AS:11431281210625239@1702062574530/Mannose-binding-lectin-pathway-and-downstream-effects-Initiation-of-the-lectin-pathway.tif": ["svg1502", "xx1", "xx2"]
    };

    function getQueryImages() {
      const query = window.location.search.substring(2); 
      return query ? query.split(",") : [];
    }

    async function loadSVG(svgName) {
      const response = await fetch(`svg/${svgName}.svg`);
      if (!response.ok) throw new Error("SVG not found: " + svgName);
      return await response.text();
    }

    function makeSVGResponsive(svgCode) {
      // Parse as XML so we only edit the root <svg>
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgCode, "image/svg+xml");
      const svgEl = doc.documentElement;

      if (!svgEl || svgEl.tagName.toLowerCase() !== "svg") {
        return svgCode; // not an SVG; bail out
      }

      // Read original width/height from root (may include units like "1280px")
      const rawW = svgEl.getAttribute("width");
      const rawH = svgEl.getAttribute("height");
      const numW = rawW ? parseFloat(rawW) : null;
      const numH = rawH ? parseFloat(rawH) : null;

      // If no viewBox, try to set one
      if (!svgEl.hasAttribute("viewBox")) {
        if (numW && numH) {
          svgEl.setAttribute("viewBox", `0 0 ${numW} ${numH}`);
        } else {
          // Try to infer from a large background <rect>
          const bgRect = doc.querySelector("rect[width][height]");
          const rW = bgRect ? parseFloat(bgRect.getAttribute("width")) : null;
          const rH = bgRect ? parseFloat(bgRect.getAttribute("height")) : null;
          if (rW && rH) {
            svgEl.setAttribute("viewBox", `0 0 ${rW} ${rH}`);
          } else {
            // Last-resort fallback that won't crash layout
            svgEl.setAttribute("viewBox", "0 0 100 100");
          }
        }
      }

      // Remove ONLY root width/height so CSS controls size
      svgEl.removeAttribute("width");
      svgEl.removeAttribute("height");

      // Ensure predictable scaling (optional)
      if (!svgEl.hasAttribute("preserveAspectRatio")) {
        svgEl.setAttribute("preserveAspectRatio", "xMidYMid meet");
      }

      // Serialize back to string
      const serializer = new XMLSerializer();
      return serializer.serializeToString(svgEl);
    }

    async function render() {
      const container = document.getElementById("output");
      const queryImages = getQueryImages();

      if (queryImages.length === 0) {
        container.innerHTML = "<p>No image URL provided.</p>";
        return;
      }

      const joinedKey = queryImages.join(",");
      const entry = library[joinedKey];

      if (entry) {
        const [svgName, ...placeholders] = entry;
        try {
          let svgCode = await loadSVG(svgName);
          // Keep URLs encoded exactly as provided
          queryImages.forEach((url, index) => {
            const safeUrl = url.trim();
            const placeholder = placeholders[index];
            svgCode = svgCode.replaceAll(placeholder, safeUrl);
          });

          // Make only the ROOT <svg> responsive
          svgCode = makeSVGResponsive(svgCode);

          const div = document.createElement("div");
          div.className = "item";
          div.innerHTML = `<h3>${svgName}.svg</h3>${svgCode}`;
          container.appendChild(div);

        } catch (err) {
          container.innerHTML = `<p class="notice">Error loading SVG: ${err.message}</p>`;
        }

      } else {
        // Show all input images as <img> when no match
        queryImages.forEach(url => {
          const div = document.createElement("div");
          div.className = "item";
          div.innerHTML = `
            <img src="${url}" alt="Unlabeled image">
            <p class="notice">⚠️ No labels found for this image.</p>
          `;
          container.appendChild(div);
        });
      }
    }

    render();
  </script>
</body>
</html>
